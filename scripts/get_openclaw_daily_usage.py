#!/usr/bin/env python3
"""
OpenClaw Daily Token Usage Getter - Final Working Version

This script fetches daily token usage from OpenClaw gateway using WebSocket API.

Based on code analysis of https://github.com/openclaw/openclaw:
- WebSocket connection is made to /gateway endpoint with HTTP upgrade
- Uses "usage.cost" method to get daily usage data
- Authentication requires:
  1. Bearer token in Authorization header
  2. Token also in connect.params.auth.deviceToken field
  3. Device identity (if gateway doesn't have allowInsecureAuth)
  4. Correct client ID and mode

IMPORTANT: Your OpenClaw gateway may require device identity for authentication.
To check if your gateway allows insecure auth, check your config for:
  gateway.controlUi.allowInsecureAuth: true
  OR
  gateway.controlUi.dangerouslyDisableDeviceAuth: true

If neither is enabled, you need device identity which is complex to implement.

Usage:
    export OPENCLAW_TOKEN="your_token"
    python3 get_openclaw_daily_usage.py --days 7 --client test

Or with insecure auth enabled on gateway:
    export OPENCLAW_TOKEN="your_token"
    python3 get_openclaw_daily_usage.py --days 7

Author: Generated by Claude Code
 dichotomy from OpenClaw source code analysis
"""

import asyncio
import json
import os
import argparse
import sqlite3
from datetime import datetime, timedelta
import sys
import uuid
import platform


def format_tokens(tokens: int) -> str:
    """Format tokens with human-readable units (K, M, G, etc.)"""
    if tokens >= 1_000_000_000:
        return f"{tokens / 1_000_000_000:.2f}B"
    elif tokens >= 1_000_000:
        return f"{tokens / 1_000_000:.2f}M"
    elif tokens >= 1_000:
        return f"{tokens / 1_000:.2f}K"
    else:
        return str(tokens)


def get_tool_name() -> str:
    """Detect the tool name based on the gateway URL or environment"""
    # Check if we're accessing OpenClaw gateway
    if os.getenv('OPENCLAW_TOKEN'):
        return "openclaw"
    # Check for other tools via environment variables
    if os.getenv('CLAUDE_API_KEY') or os.getenv('ANTHROPIC_API_KEY'):
        return "claude"
    if os.getenv('QWEN_API_KEY') or os.getenv('DASHSCOPE_API_KEY'):
        return "qwen"
    return "unknown"

try:
    import websockets
except ImportError:
    print("Error: websockets module not installed")
    print("Install with: pip install websockets")
    sys.exit(1)


async def get_usage_via_websocket(gateway_url: str, token: str, days: int, client_id: str):
    """
    Fetch usage data from OpenClaw gateway using WebSocket API.
    """
    # Calculate date range
    end_date = datetime.now().strftime("%Y-%m-%d")
    start_date = (datetime.now() - timedelta(days=days-1)).strftime("%Y-%m-%d")

    print(f"Fetching {days} days of usage data...")
    print(f"Date range: {start_date} to {end_date}")

    # Parse gateway URL for WebSocket connection
    if gateway_url.startswith("https://"):
        ws_scheme = "wss://"
        gateway_host = gateway_url[8:]
    elif gateway_url.startswith("http://"):
        ws_scheme = "ws://"
        gateway_host = gateway_url[7:]
    else:
        ws_scheme = "ws://"
        gateway_host = gateway_url

    ws_url = f"{ws_scheme}{gateway_host}/gateway"
    print(f"Connecting to WebSocket: {ws_url}")

    extra_headers = {
        "Authorization": f"Bearer {token}",
        "Origin": gateway_url,
    }

    try:
        async with websockets.connect(ws_url, additional_headers=extra_headers) as websocket:
            print("Connected to gateway!")

            # Wait for connect.challenge
            message = await asyncio.wait_for(websocket.recv(), timeout=10)
            response = json.loads(message)

            if response.get("type") != "event" or response.get("event") != "connect.challenge":
                print(f"Unexpected initial message: {response}")
                return None

            nonce = response.get("payload", {}).get("nonce")

            # Build connect params
            # Using openclaw-control-ui client with ui mode requires:
            # gateway.controlUi.dangerouslyDisableDeviceAuth: true in config
            connect_params = {
                "minProtocol": 3,
                "maxProtocol": 3,
                "client": {
                    "id": "openclaw-control-ui",
                    "displayName": "OpenClaw Usage Getter",
                    "version": "1.0.0",
                    "platform": "web",
                    "mode": "ui",
                },
                "role": "operator",
                "scopes": ["operator.admin", "operator.read", "operator.write"],
                "auth": {
                    "token": token,  # Use token when dangerouslyDisableDeviceAuth is enabled
                },
                "userAgent": "OpenClaw-Usage-Getter/1.0",
                "locale": "en-US",
            }

            connect_request = {
                "type": "req",
                "id": str(uuid.uuid4()),
                "method": "connect",
                "params": connect_params
            }

            await websocket.send(json.dumps(connect_request))

            # Wait for hello-ok response
            hello = await asyncio.wait_for(websocket.recv(), timeout=10)
            hello_resp = json.loads(hello)

            if hello_resp.get("type") != "res":
                print(f"Unexpected response type: {hello_resp.get('type')}")
                return None

            if not hello_resp.get("ok"):
                error = hello_resp.get("error", {})
                print(f"Connect failed: {error.get('code', 'Unknown')}: {error.get('message', '')}")
                print(f"Error details: {error.get('details', {})}")
                return None

            print("Connection established successfully!")

            # Get available methods
            payload = hello_resp.get("payload", {})
            features = payload.get("features", {})
            available_methods = features.get("methods", [])

            # Check if usage.cost is available
            if "usage.cost" not in available_methods:
                print("Error: usage.cost method not available")
                return None

            # Send usage.cost request
            usage_request_id = str(uuid.uuid4())
            usage_params = {
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "mode": "utc"
            }

            usage_request = {
                "type": "req",
                "id": usage_request_id,
                "method": "usage.cost",
                "params": usage_params
            }

            await websocket.send(json.dumps(usage_request))

            # Wait for response
            response = await asyncio.wait_for(websocket.recv(), timeout=10)

            return json.loads(response)

    except websockets.exceptions.ConnectionClosed as e:
        print(f"WebSocket connection closed: {e.code} {e.reason}")
        return None
    except asyncio.TimeoutError:
        print("Timeout waiting for response")
        return None
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return None


def parse_usage_response(response: dict) -> dict:
    """Parse the usage cost response and extract daily token usage."""
    if not response or not isinstance(response, dict):
        return {}

    if response.get("type") == "error" or response.get("error"):
        error_msg = response.get("error", response.get("message", "Unknown error"))
        return {}

    if response.get("type") == "res":
        if not response.get("ok"):
            return {}
        result = response.get("payload", {})
    else:
        result = response.get("result", response)

    if not result:
        return {}

    daily_usage = {}
    daily_array = result.get("daily", [])

    if not daily_array:
        if isinstance(result, dict):
            for key, value in result.items():
                if isinstance(value, list) and key != "result":
                    daily_array = value
                    break

    for day_entry in daily_array:
        if isinstance(day_entry, dict):
            date = day_entry.get("date")
            tokens = day_entry.get("tokens") or day_entry.get("totalTokens") or day_entry.get("total")
            if date and tokens is not None:
                daily_usage[date] = int(tokens)

    return daily_usage


def save_to_database(db_path: str, daily_usage: dict, tool_name: str) -> None:
    """Save usage data to SQLite database"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Ensure tool_name column exists
    cursor.execute("PRAGMA table_info(daily_usage)")
    columns = [col[1] for col in cursor.fetchall()]
    if "tool_name" not in columns:
        cursor.execute("ALTER TABLE daily_usage ADD COLUMN tool_name TEXT DEFAULT 'unknown'")

    for date, tokens in daily_usage.items():
        cursor.execute('''
            INSERT OR REPLACE INTO daily_usage (date, tokens_used, tool_name)
            VALUES (?, ?, ?)
        ''', (date, tokens, tool_name))

    conn.commit()
    conn.close()


def print_usage_summary(daily_usage: dict, tool_name: str = "unknown") -> None:
    """Print a summary of the usage data"""
    if not daily_usage:
        print("No usage data available.")
        return

    print("\n" + "="*50)
    print(f"DAILY TOKEN USAGE SUMMARY [{tool_name.upper()}]")
    print("="*50)

    total_tokens = 0
    for date, tokens in sorted(daily_usage.items(), reverse=True):
        formatted = format_tokens(tokens)
        print(f"{date}: {formatted} tokens ({tokens:,})")
        total_tokens += tokens

    print("-"*50)
    print(f"TOTAL TOKENS: {format_tokens(total_tokens)} ({total_tokens:,})")
    print(f"DAYS WITH USAGE: {len(daily_usage)}")
    if len(daily_usage) > 0:
        avg = total_tokens // len(daily_usage)
        print(f"AVERAGE PER DAY: {format_tokens(avg)} ({avg:,})")


def print_database_summary(db_path: str) -> None:
    """Print summary from database"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    print("\n" + "="*60)
    print("DATABASE SUMMARY")
    print("="*60)

    # Check if tool_name column exists
    cursor.execute("PRAGMA table_info(daily_usage)")
    columns = [col[1] for col in cursor.fetchall()]
    has_tool_name = "tool_name" in columns

    if has_tool_name:
        cursor.execute("SELECT SUM(tokens_used), COUNT(*), AVG(tokens_used), tool_name FROM daily_usage GROUP BY tool_name")
        rows = cursor.fetchall()
        for row in rows:
            total, count, avg, tool_name = row
            print(f"\n[{tool_name.upper()}]")
            print(f"  Total entries: {count}")
            print(f"  Total tokens: {format_tokens(total)} ({total:,})")
            if avg:
                print(f"  Average per day: {format_tokens(avg)} ({avg:,.0f})")

        # Get date range per tool
        cursor.execute("SELECT MIN(date), MAX(date), tool_name FROM daily_usage GROUP BY tool_name")
        print("\nDate ranges:")
        for row in cursor.fetchall():
            min_date, max_date, tool_name = row
            print(f"  [{tool_name}]: {min_date} to {max_date}")
    else:
        # Old format without tool_name
        cursor.execute("SELECT SUM(tokens_used), COUNT(*), AVG(tokens_used) FROM daily_usage")
        total, count, avg = cursor.fetchone()
        print(f"Total entries: {count}")
        print(f"Total tokens: {format_tokens(total)} ({total:,})")
        if avg:
            print(f"Average per day: {format_tokens(avg)} ({avg:,.0f})")

    cursor.execute("SELECT date, tokens_used FROM daily_usage ORDER BY date DESC LIMIT 7")
    print("\nRecent 7 days:")
    for row in cursor.fetchall():
        formatted = format_tokens(row[1])
        print(f"  {row[0]}: {formatted} tokens ({row[1]:,})")

    conn.close()


async def main():
    parser = argparse.ArgumentParser(description='Get AI tool daily token usage')
    parser.add_argument('--url', default='http://127.0.0.1:18789', help='AI gateway URL')
    parser.add_argument('--token', help='AI gateway token')
    parser.add_argument('--days', type=int, default=7, help='Number of days to fetch (default: 7)')
    parser.add_argument('--client', default='openclaw-control-ui', help='Client ID (default: openclaw-control-ui)')
    parser.add_argument('--save', action='store_true', help='Save data to database')
    parser.add_argument('--status', action='store_true', help='Show database status only')
    parser.add_argument('--list-all', action='store_true', help='List all data in database')
    parser.add_argument('--tool', help='Tool name (openclaw, claude, qwen, etc.)')

    args = parser.parse_args()

    db_path = os.path.expanduser("~/.ai_token_usage.db")

    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS daily_usage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            date TEXT UNIQUE,
            tokens_used INTEGER,
            tool_name TEXT DEFAULT 'unknown',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

    if args.status:
        print_database_summary(db_path)
        return

    if args.list_all:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Check if tool_name column exists
        cursor.execute("PRAGMA table_info(daily_usage)")
        columns = [col[1] for col in cursor.fetchall()]
        has_tool_name = "tool_name" in columns

        print("\nAll recorded usage data:")
        if has_tool_name:
            cursor.execute("SELECT date, tokens_used, tool_name FROM daily_usage ORDER BY date DESC")
            for row in cursor.fetchall():
                formatted = format_tokens(row[1])
                print(f"  {row[0]}: {formatted} tokens ({row[1]:,}) [{row[2]}]")
        else:
            cursor.execute("SELECT date, tokens_used FROM daily_usage ORDER BY date DESC")
            for row in cursor.fetchall():
                formatted = format_tokens(row[1])
                print(f"  {row[0]}: {formatted} tokens ({row[1]:,})")
        conn.close()
        return

    token = args.token or os.getenv('OPENCLAW_TOKEN')
    if not token:
        print("Error: Token required")
        print("Set OPENCLAW_TOKEN environment variable or use --token flag")
        print("\nExample:")
        print('  export OPENCLAW_TOKEN="your_token"')
        print('  python3 get_openclaw_daily_usage.py --days 7')
        return

    # Determine tool name
    tool_name = args.tool or get_tool_name()

    response = await get_usage_via_websocket(args.url, token, args.days, args.client)

    if response:
        daily_usage = parse_usage_response(response)

        if daily_usage:
            if args.save:
                save_to_database(db_path, daily_usage, tool_name)
                print(f"\nSaved {len(daily_usage)} days of data to database")

            print_usage_summary(daily_usage, tool_name)
            print_database_summary(db_path)
        else:
            print("\nCould not parse usage data from response.")
            print("Full response:")
            print(json.dumps(response, indent=2)[:2000])
    else:
        print("\nFailed to retrieve usage data.")
        print("\nPossible reasons:")
        print("- Gateway not running at", args.url)
        print("- Invalid or missing token")
        print("- Gateway requires device identity (not implemented in this script)")
        print("- Check your gateway config for allowInsecureAuth or dangerouslyDisableDeviceAuth")


if __name__ == "__main__":
    asyncio.run(main())