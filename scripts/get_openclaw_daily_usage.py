#!/usr/bin/env python3
"""
OpenClaw Daily Token Usage Getter - Final Working Version

This script fetches daily token usage from OpenClaw gateway using WebSocket API.

Based on code analysis of https://github.com/openclaw/openclaw:
- WebSocket connection is made to /gateway endpoint with HTTP upgrade
- Uses "usage.cost" method to get daily usage data
- Authentication requires:
  1. Bearer token in Authorization header
  2. Token also in connect.params.auth.deviceToken field
  3. Device identity (if gateway doesn't have allowInsecureAuth)
  4. Correct client ID and mode

IMPORTANT: Your OpenClaw gateway may require device identity for authentication.
To check if your gateway allows insecure auth, check your config for:
  gateway.controlUi.allowInsecureAuth: true
  OR
  gateway.controlUi.dangerouslyDisableDeviceAuth: true

If neither is enabled, you need device identity which is complex to implement.

Usage:
    export OPENCLAW_TOKEN="your_token"
    python3 get_openclaw_daily_usage.py --days 7 --client test

Or with insecure auth enabled on gateway:
    export OPENCLAW_TOKEN="your_token"
    python3 get_openclaw_daily_usage.py --days 7

Author: Generated by Claude Code
 dichotomy from OpenClaw source code analysis
"""

import asyncio
import json
import os
import argparse
import sqlite3
from datetime import datetime, timedelta
import sys
import uuid

try:
    import websockets
except ImportError:
    print("Error: websockets module not installed")
    print("Install with: pip install websockets")
    sys.exit(1)


async def get_usage_via_websocket(gateway_url: str, token: str, days: int, client_id: str):
    """
    Fetch usage data from OpenClaw gateway using WebSocket API.
    """
    # Calculate date range
    end_date = datetime.now().strftime("%Y-%m-%d")
    start_date = (datetime.now() - timedelta(days=days-1)).strftime("%Y-%m-%d")

    print(f"Fetching {days} days of usage data...")
    print(f"Date range: {start_date} to {end_date}")

    # Parse gateway URL for WebSocket connection
    if gateway_url.startswith("https://"):
        ws_scheme = "wss://"
        gateway_host = gateway_url[8:]
    elif gateway_url.startswith("http://"):
        ws_scheme = "ws://"
        gateway_host = gateway_url[7:]
    else:
        ws_scheme = "ws://"
        gateway_host = gateway_url

    ws_url = f"{ws_scheme}{gateway_host}/gateway"
    print(f"Connecting to WebSocket: {ws_url}")

    extra_headers = {
        "Authorization": f"Bearer {token}",
        "Origin": gateway_url,
    }

    try:
        async with websockets.connect(ws_url, additional_headers=extra_headers) as websocket:
            print("Connected to gateway!")

            # Wait for connect.challenge
            message = await asyncio.wait_for(websocket.recv(), timeout=10)
            response = json.loads(message)

            if response.get("type") != "event" or response.get("event") != "connect.challenge":
                print(f"Unexpected initial message: {response}")
                return None

            nonce = response.get("payload", {}).get("nonce")

            # Build connect params
            # Using openclaw-control-ui client with ui mode requires:
            # gateway.controlUi.dangerouslyDisableDeviceAuth: true in config
            connect_params = {
                "minProtocol": 3,
                "maxProtocol": 3,
                "client": {
                    "id": "openclaw-control-ui",
                    "displayName": "OpenClaw Usage Getter",
                    "version": "1.0.0",
                    "platform": "web",
                    "mode": "ui",
                },
                "role": "operator",
                "scopes": ["operator.admin", "operator.read", "operator.write"],
                "auth": {
                    "token": token,  # Use token when dangerouslyDisableDeviceAuth is enabled
                },
                "userAgent": "OpenClaw-Usage-Getter/1.0",
                "locale": "en-US",
            }

            connect_request = {
                "type": "req",
                "id": str(uuid.uuid4()),
                "method": "connect",
                "params": connect_params
            }

            await websocket.send(json.dumps(connect_request))

            # Wait for hello-ok response
            hello = await asyncio.wait_for(websocket.recv(), timeout=10)
            hello_resp = json.loads(hello)

            if hello_resp.get("type") != "res":
                print(f"Unexpected response type: {hello_resp.get('type')}")
                return None

            if not hello_resp.get("ok"):
                error = hello_resp.get("error", {})
                print(f"Connect failed: {error.get('code', 'Unknown')}: {error.get('message', '')}")
                print(f"Error details: {error.get('details', {})}")
                return None

            print("Connection established successfully!")

            # Get available methods
            payload = hello_resp.get("payload", {})
            features = payload.get("features", {})
            available_methods = features.get("methods", [])

            # Check if usage.cost is available
            if "usage.cost" not in available_methods:
                print("Error: usage.cost method not available")
                return None

            # Send usage.cost request
            usage_request_id = str(uuid.uuid4())
            usage_params = {
                "startDate": start_date,
                "endDate": end_date,
                "days": days,
                "mode": "utc"
            }

            usage_request = {
                "type": "req",
                "id": usage_request_id,
                "method": "usage.cost",
                "params": usage_params
            }

            await websocket.send(json.dumps(usage_request))

            # Wait for response
            response = await asyncio.wait_for(websocket.recv(), timeout=10)

            return json.loads(response)

    except websockets.exceptions.ConnectionClosed as e:
        print(f"WebSocket connection closed: {e.code} {e.reason}")
        return None
    except asyncio.TimeoutError:
        print("Timeout waiting for response")
        return None
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return None


def parse_usage_response(response: dict) -> dict:
    """Parse the usage cost response and extract daily token usage."""
    if not response or not isinstance(response, dict):
        return {}

    if response.get("type") == "error" or response.get("error"):
        error_msg = response.get("error", response.get("message", "Unknown error"))
        return {}

    if response.get("type") == "res":
        if not response.get("ok"):
            return {}
        result = response.get("payload", {})
    else:
        result = response.get("result", response)

    if not result:
        return {}

    daily_usage = {}
    daily_array = result.get("daily", [])

    if not daily_array:
        if isinstance(result, dict):
            for key, value in result.items():
                if isinstance(value, list) and key != "result":
                    daily_array = value
                    break

    for day_entry in daily_array:
        if isinstance(day_entry, dict):
            date = day_entry.get("date")
            tokens = day_entry.get("tokens") or day_entry.get("totalTokens") or day_entry.get("total")
            if date and tokens is not None:
                daily_usage[date] = int(tokens)

    return daily_usage


def save_to_database(db_path: str, daily_usage: dict) -> None:
    """Save usage data to SQLite database"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    for date, tokens in daily_usage.items():
        cursor.execute('''
            INSERT OR REPLACE INTO daily_usage (date, tokens_used)
            VALUES (?, ?)
        ''', (date, tokens))

    conn.commit()
    conn.close()


def print_usage_summary(daily_usage: dict) -> None:
    """Print a summary of the usage data"""
    if not daily_usage:
        print("No usage data available.")
        return

    print("\n" + "="*50)
    print("DAILY TOKEN USAGE SUMMARY")
    print("="*50)

    total_tokens = 0
    for date, tokens in sorted(daily_usage.items(), reverse=True):
        print(f"{date}: {tokens:,} tokens")
        total_tokens += tokens

    print("-"*50)
    print(f"TOTAL TOKENS: {total_tokens:,}")
    print(f"DAYS WITH USAGE: {len(daily_usage)}")
    if len(daily_usage) > 0:
        print(f"AVERAGE PER DAY: {total_tokens // len(daily_usage):,}")


def print_database_summary(db_path: str) -> None:
    """Print summary from database"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    print("\n" + "="*50)
    print("DATABASE SUMMARY")
    print("="*50)

    cursor.execute("SELECT SUM(tokens_used), COUNT(*), AVG(tokens_used) FROM daily_usage")
    total, count, avg = cursor.fetchone()
    print(f"Total entries: {count}")
    print(f"Total tokens: {total:,}")
    if avg:
        print(f"Average per day: {avg:,.0f}")

    cursor.execute("SELECT date, tokens_used FROM daily_usage ORDER BY date DESC LIMIT 7")
    print("\nRecent 7 days:")
    for row in cursor.fetchall():
        print(f"  {row[0]}: {row[1]:,} tokens")

    conn.close()


async def main():
    parser = argparse.ArgumentParser(description='Get OpenClaw daily token usage')
    parser.add_argument('--url', default='http://127.0.0.1:18789', help='OpenClaw gateway URL')
    parser.add_argument('--token', help='OpenClaw gateway token')
    parser.add_argument('--days', type=int, default=7, help='Number of days to fetch (default: 7)')
    parser.add_argument('--client', default='openclaw-control-ui', help='Client ID (default: openclaw-control-ui)')
    parser.add_argument('--save', action='store_true', help='Save data to database')
    parser.add_argument('--status', action='store_true', help='Show database status only')
    parser.add_argument('--list-all', action='store_true', help='List all data in database')

    args = parser.parse_args()

    db_path = os.path.expanduser("~/.openclaw_usage.db")

    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS daily_usage (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            date TEXT UNIQUE,
            tokens_used INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()

    if args.status:
        print_database_summary(db_path)
        return

    if args.list_all:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT date, tokens_used FROM daily_usage ORDER BY date DESC")
        print("\nAll recorded usage data:")
        for row in cursor.fetchall():
            print(f"  {row[0]}: {row[1]:,} tokens")
        conn.close()
        return

    token = args.token or os.getenv('OPENCLAW_TOKEN')
    if not token:
        print("Error: Token required")
        print("Set OPENCLAW_TOKEN environment variable or use --token flag")
        print("\nExample:")
        print('  export OPENCLAW_TOKEN="your_token"')
        print('  python3 get_openclaw_daily_usage.py --days 7')
        return

    response = await get_usage_via_websocket(args.url, token, args.days, args.client)

    if response:
        daily_usage = parse_usage_response(response)

        if daily_usage:
            if args.save:
                save_to_database(db_path, daily_usage)
                print(f"\nSaved {len(daily_usage)} days of data to database")

            print_usage_summary(daily_usage)
            print_database_summary(db_path)
        else:
            print("\nCould not parse usage data from response.")
            print("Full response:")
            print(json.dumps(response, indent=2)[:2000])
    else:
        print("\nFailed to retrieve usage data.")
        print("\nPossible reasons:")
        print("- Gateway not running at", args.url)
        print("- Invalid or missing token")
        print("- Gateway requires device identity (not implemented in this script)")
        print("- Check your gateway config for allowInsecureAuth or dangerouslyDisableDeviceAuth")


if __name__ == "__main__":
    asyncio.run(main())